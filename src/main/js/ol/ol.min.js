/*
 * Copyright (C) 2021 con terra GmbH (info@conterra.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports, require("ol/Feature.js"), require("ol/geom/Point.js"), require("ol/geom/MultiPoint.js"), require("ol/geom/LineString.js"), require("ol/geom/MultiLineString.js"), require("ol/geom/Polygon.js"), require("ol/geom/MultiPolygon.js")) : "function" == typeof define && define.amd ? define(["exports", "ol/Feature.js", "ol/geom/Point.js", "ol/geom/MultiPoint.js", "ol/geom/LineString.js", "ol/geom/MultiLineString.js", "ol/geom/Polygon.js", "ol/geom/MultiPolygon.js"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).flatgeobuf = {}, t.ol.Feature, t.ol.geom.Point, t.ol.geom.MultiPoint, t.ol.geom.LineString, t.ol.geom.MultiLineString, t.ol.geom.Polygon, t.ol.geom.MultiPolygon)
}(this, (function (t, e, r, n, s, i, o, a) {
    "use strict";

    function h(t) {
        return t && "object" == typeof t && "default" in t ? t : {default: t}
    }

    var u = h(e), c = h(r), l = h(n), b = h(s), f = h(i), d = h(o), _ = h(a);
    const p = new Int32Array(2), y = new Float32Array(p.buffer), g = new Float64Array(p.buffer),
        w = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0];

    class m {
        constructor(t, e) {
            this.low = 0 | t, this.high = 0 | e
        }

        static create(t, e) {
            return 0 == t && 0 == e ? m.ZERO : new m(t, e)
        }

        toFloat64() {
            return (this.low >>> 0) + 4294967296 * this.high
        }

        equals(t) {
            return this.low == t.low && this.high == t.high
        }
    }

    var v;
    m.ZERO = new m(0, 0), function (t) {
        t[t.UTF8_BYTES = 1] = "UTF8_BYTES", t[t.UTF16_STRING = 2] = "UTF16_STRING"
    }(v || (v = {}));

    class I {
        constructor(t) {
            this.bytes_ = t, this.position_ = 0
        }

        static allocate(t) {
            return new I(new Uint8Array(t))
        }

        clear() {
            this.position_ = 0
        }

        bytes() {
            return this.bytes_
        }

        position() {
            return this.position_
        }

        setPosition(t) {
            this.position_ = t
        }

        capacity() {
            return this.bytes_.length
        }

        readInt8(t) {
            return this.readUint8(t) << 24 >> 24
        }

        readUint8(t) {
            return this.bytes_[t]
        }

        readInt16(t) {
            return this.readUint16(t) << 16 >> 16
        }

        readUint16(t) {
            return this.bytes_[t] | this.bytes_[t + 1] << 8
        }

        readInt32(t) {
            return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24
        }

        readUint32(t) {
            return this.readInt32(t) >>> 0
        }

        readInt64(t) {
            return new m(this.readInt32(t), this.readInt32(t + 4))
        }

        readUint64(t) {
            return new m(this.readUint32(t), this.readUint32(t + 4))
        }

        readFloat32(t) {
            return p[0] = this.readInt32(t), y[0]
        }

        readFloat64(t) {
            return p[w ? 0 : 1] = this.readInt32(t), p[w ? 1 : 0] = this.readInt32(t + 4), g[0]
        }

        writeInt8(t, e) {
            this.bytes_[t] = e
        }

        writeUint8(t, e) {
            this.bytes_[t] = e
        }

        writeInt16(t, e) {
            this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8
        }

        writeUint16(t, e) {
            this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8
        }

        writeInt32(t, e) {
            this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24
        }

        writeUint32(t, e) {
            this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24
        }

        writeInt64(t, e) {
            this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high)
        }

        writeUint64(t, e) {
            this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high)
        }

        writeFloat32(t, e) {
            y[0] = e, this.writeInt32(t, p[0])
        }

        writeFloat64(t, e) {
            g[0] = e, this.writeInt32(t, p[w ? 0 : 1]), this.writeInt32(t + 4, p[w ? 1 : 0])
        }

        getBufferIdentifier() {
            if (this.bytes_.length < this.position_ + 4 + 4) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
            let t = "";
            for (let e = 0; e < 4; e++) t += String.fromCharCode(this.readInt8(this.position_ + 4 + e));
            return t
        }

        __offset(t, e) {
            const r = t - this.readInt32(t);
            return e < this.readInt16(r) ? this.readInt16(r + e) : 0
        }

        __union(t, e) {
            return t.bb_pos = e + this.readInt32(e), t.bb = this, t
        }

        __string(t, e) {
            t += this.readInt32(t);
            const r = this.readInt32(t);
            let n = "", s = 0;
            if (t += 4, e === v.UTF8_BYTES) return this.bytes_.subarray(t, t + r);
            for (; s < r;) {
                let e;
                const r = this.readUint8(t + s++);
                if (r < 192) e = r; else {
                    const n = this.readUint8(t + s++);
                    if (r < 224) e = (31 & r) << 6 | 63 & n; else {
                        const i = this.readUint8(t + s++);
                        if (r < 240) e = (15 & r) << 12 | (63 & n) << 6 | 63 & i; else {
                            e = (7 & r) << 18 | (63 & n) << 12 | (63 & i) << 6 | 63 & this.readUint8(t + s++)
                        }
                    }
                }
                e < 65536 ? n += String.fromCharCode(e) : (e -= 65536, n += String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)))
            }
            return n
        }

        __union_with_string(t, e) {
            return "string" == typeof t ? this.__string(e) : this.__union(t, e)
        }

        __indirect(t) {
            return t + this.readInt32(t)
        }

        __vector(t) {
            return t + this.readInt32(t) + 4
        }

        __vector_len(t) {
            return this.readInt32(t + this.readInt32(t))
        }

        __has_identifier(t) {
            if (4 != t.length) throw new Error("FlatBuffers: file identifier must be length 4");
            for (let e = 0; e < 4; e++) if (t.charCodeAt(e) != this.readInt8(this.position() + 4 + e)) return !1;
            return !0
        }

        createLong(t, e) {
            return m.create(t, e)
        }

        createScalarList(t, e) {
            const r = [];
            for (let n = 0; n < e; ++n) null !== t(n) && r.push(t(n));
            return r
        }

        createObjList(t, e) {
            const r = [];
            for (let n = 0; n < e; ++n) {
                const e = t(n);
                null !== e && r.push(e.unpack())
            }
            return r
        }
    }

    class F {
        constructor(t) {
            let e;
            this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, e = t || 1024, this.bb = I.allocate(e), this.space = e
        }

        clear() {
            this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null
        }

        forceDefaults(t) {
            this.force_defaults = t
        }

        dataBuffer() {
            return this.bb
        }

        asUint8Array() {
            return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset())
        }

        prep(t, e) {
            t > this.minalign && (this.minalign = t);
            const r = 1 + ~(this.bb.capacity() - this.space + e) & t - 1;
            for (; this.space < r + t + e;) {
                const t = this.bb.capacity();
                this.bb = F.growByteBuffer(this.bb), this.space += this.bb.capacity() - t
            }
            this.pad(r)
        }

        pad(t) {
            for (let e = 0; e < t; e++) this.bb.writeInt8(--this.space, 0)
        }

        writeInt8(t) {
            this.bb.writeInt8(this.space -= 1, t)
        }

        writeInt16(t) {
            this.bb.writeInt16(this.space -= 2, t)
        }

        writeInt32(t) {
            this.bb.writeInt32(this.space -= 4, t)
        }

        writeInt64(t) {
            this.bb.writeInt64(this.space -= 8, t)
        }

        writeFloat32(t) {
            this.bb.writeFloat32(this.space -= 4, t)
        }

        writeFloat64(t) {
            this.bb.writeFloat64(this.space -= 8, t)
        }

        addInt8(t) {
            this.prep(1, 0), this.writeInt8(t)
        }

        addInt16(t) {
            this.prep(2, 0), this.writeInt16(t)
        }

        addInt32(t) {
            this.prep(4, 0), this.writeInt32(t)
        }

        addInt64(t) {
            this.prep(8, 0), this.writeInt64(t)
        }

        addFloat32(t) {
            this.prep(4, 0), this.writeFloat32(t)
        }

        addFloat64(t) {
            this.prep(8, 0), this.writeFloat64(t)
        }

        addFieldInt8(t, e, r) {
            (this.force_defaults || e != r) && (this.addInt8(e), this.slot(t))
        }

        addFieldInt16(t, e, r) {
            (this.force_defaults || e != r) && (this.addInt16(e), this.slot(t))
        }

        addFieldInt32(t, e, r) {
            (this.force_defaults || e != r) && (this.addInt32(e), this.slot(t))
        }

        addFieldInt64(t, e, r) {
            !this.force_defaults && e.equals(r) || (this.addInt64(e), this.slot(t))
        }

        addFieldFloat32(t, e, r) {
            (this.force_defaults || e != r) && (this.addFloat32(e), this.slot(t))
        }

        addFieldFloat64(t, e, r) {
            (this.force_defaults || e != r) && (this.addFloat64(e), this.slot(t))
        }

        addFieldOffset(t, e, r) {
            (this.force_defaults || e != r) && (this.addOffset(e), this.slot(t))
        }

        addFieldStruct(t, e, r) {
            e != r && (this.nested(e), this.slot(t))
        }

        nested(t) {
            if (t != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.")
        }

        notNested() {
            if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.")
        }

        slot(t) {
            null !== this.vtable && (this.vtable[t] = this.offset())
        }

        offset() {
            return this.bb.capacity() - this.space
        }

        static growByteBuffer(t) {
            const e = t.capacity();
            if (3221225472 & e) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
            const r = e << 1, n = I.allocate(r);
            return n.setPosition(r - e), n.bytes().set(t.bytes(), r - e), n
        }

        addOffset(t) {
            this.prep(4, 0), this.writeInt32(this.offset() - t + 4)
        }

        startObject(t) {
            this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t;
            for (let e = 0; e < t; e++) this.vtable[e] = 0;
            this.isNested = !0, this.object_start = this.offset()
        }

        endObject() {
            if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
            this.addInt32(0);
            const t = this.offset();
            let e = this.vtable_in_use - 1;
            for (; e >= 0 && 0 == this.vtable[e]; e--) ;
            const r = e + 1;
            for (; e >= 0; e--) this.addInt16(0 != this.vtable[e] ? t - this.vtable[e] : 0);
            this.addInt16(t - this.object_start);
            const n = 2 * (r + 2);
            this.addInt16(n);
            let s = 0;
            const i = this.space;
            t:for (e = 0; e < this.vtables.length; e++) {
                const t = this.bb.capacity() - this.vtables[e];
                if (n == this.bb.readInt16(t)) {
                    for (let e = 2; e < n; e += 2) if (this.bb.readInt16(i + e) != this.bb.readInt16(t + e)) continue t;
                    s = this.vtables[e];
                    break
                }
            }
            return s ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, s - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t
        }

        finish(t, e, r) {
            const n = r ? 4 : 0;
            if (e) {
                const t = e;
                if (this.prep(this.minalign, 8 + n), 4 != t.length) throw new Error("FlatBuffers: file identifier must be length 4");
                for (let e = 3; e >= 0; e--) this.writeInt8(t.charCodeAt(e))
            }
            this.prep(this.minalign, 4 + n), this.addOffset(t), n && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space)
        }

        finishSizePrefixed(t, e) {
            this.finish(t, e, !0)
        }

        requiredField(t, e) {
            const r = this.bb.capacity() - t, n = r - this.bb.readInt32(r);
            if (!(0 != this.bb.readInt16(n + e))) throw new Error("FlatBuffers: field " + e + " must be set")
        }

        startVector(t, e, r) {
            this.notNested(), this.vector_num_elems = e, this.prep(4, t * e), this.prep(r, t * e)
        }

        endVector() {
            return this.writeInt32(this.vector_num_elems), this.offset()
        }

        createSharedString(t) {
            if (!t) return 0;
            if (this.string_maps || (this.string_maps = new Map), this.string_maps.has(t)) return this.string_maps.get(t);
            const e = this.createString(t);
            return this.string_maps.set(t, e), e
        }

        createString(t) {
            if (!t) return 0;
            let e;
            if (t instanceof Uint8Array) e = t; else {
                e = [];
                let r = 0;
                for (; r < t.length;) {
                    let n;
                    const s = t.charCodeAt(r++);
                    if (s < 55296 || s >= 56320) n = s; else {
                        n = (s << 10) + t.charCodeAt(r++) + -56613888
                    }
                    n < 128 ? e.push(n) : (n < 2048 ? e.push(n >> 6 & 31 | 192) : (n < 65536 ? e.push(n >> 12 & 15 | 224) : e.push(n >> 18 & 7 | 240, n >> 12 & 63 | 128), e.push(n >> 6 & 63 | 128)), e.push(63 & n | 128))
                }
            }
            this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length);
            for (let t = 0, r = this.space, n = this.bb.bytes(); t < e.length; t++) n[r++] = e[t];
            return this.endVector()
        }

        createLong(t, e) {
            return m.create(t, e)
        }

        createObjectOffset(t) {
            return null === t ? 0 : "string" == typeof t ? this.createString(t) : t.pack(this)
        }

        createObjectOffsetList(t) {
            const e = [];
            for (let r = 0; r < t.length; ++r) {
                const n = t[r];
                if (null === n) throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
                e.push(this.createObjectOffset(n))
            }
            return e
        }

        createStructOffsetList(t, e) {
            return e(this, t.length), this.createObjectOffsetList(t), this.endVector()
        }
    }

    var P, x, U = new Uint8Array(0);

    function S(t, e) {
        if (!t.length) return e;
        if (!e.length) return t;
        var r = new Uint8Array(t.length + e.length);
        return r.set(t), r.set(e, t.length), r
    }

    function O(t) {
        this._source = t, this._array = U, this._index = 0
    }

    O.prototype.read = function () {
        var t = this, e = t._array.subarray(t._index);
        return t._source.read().then((function (r) {
            return t._array = U, t._index = 0, r.done ? e.length > 0 ? {done: !1, value: e} : {
                done: !0,
                value: void 0
            } : {done: !1, value: S(e, r.value)}
        }))
    }, O.prototype.slice = function (t) {
        if ((t |= 0) < 0) throw new Error("invalid length");
        var e = this, r = this._array.length - this._index;
        if (this._index + t <= this._array.length) return Promise.resolve(this._array.subarray(this._index, this._index += t));
        var n = new Uint8Array(t);
        return n.set(this._array.subarray(this._index)), function s() {
            return e._source.read().then((function (i) {
                return i.done ? (e._array = U, e._index = 0, r > 0 ? n.subarray(0, r) : null) : r + i.value.length >= t ? (e._array = i.value, e._index = t - r, n.set(i.value.subarray(0, t - r), r), n) : (n.set(i.value, r), r += i.value.length, s())
            }))
        }()
    }, O.prototype.cancel = function () {
        return this._source.cancel()
    };

    class C {
        constructor(t, e, r, n, s, i, o, a, h, u) {
            this.name = t, this.type = e, this.title = r, this.description = n, this.width = s, this.precision = i, this.scale = o, this.nullable = a, this.unique = h, this.primary_key = u
        }
    }

    !function (t) {
        t[t.Byte = 0] = "Byte", t[t.UByte = 1] = "UByte", t[t.Bool = 2] = "Bool", t[t.Short = 3] = "Short", t[t.UShort = 4] = "UShort", t[t.Int = 5] = "Int", t[t.UInt = 6] = "UInt", t[t.Long = 7] = "Long", t[t.ULong = 8] = "ULong", t[t.Float = 9] = "Float", t[t.Double = 10] = "Double", t[t.String = 11] = "String", t[t.Json = 12] = "Json", t[t.DateTime = 13] = "DateTime", t[t.Binary = 14] = "Binary"
    }(P || (P = {}));

    class E {
        constructor() {
            this.bb = null, this.bb_pos = 0
        }

        __init(t, e) {
            return this.bb_pos = t, this.bb = e, this
        }

        static getRootAsColumn(t, e) {
            return (e || new E).__init(t.readInt32(t.position()) + t.position(), t)
        }

        static getSizePrefixedRootAsColumn(t, e) {
            return t.setPosition(t.position() + 4), (e || new E).__init(t.readInt32(t.position()) + t.position(), t)
        }

        name(t) {
            const e = this.bb.__offset(this.bb_pos, 4);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        type() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? this.bb.readUint8(this.bb_pos + t) : P.Byte
        }

        title(t) {
            const e = this.bb.__offset(this.bb_pos, 8);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        description(t) {
            const e = this.bb.__offset(this.bb_pos, 10);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        width() {
            const t = this.bb.__offset(this.bb_pos, 12);
            return t ? this.bb.readInt32(this.bb_pos + t) : -1
        }

        precision() {
            const t = this.bb.__offset(this.bb_pos, 14);
            return t ? this.bb.readInt32(this.bb_pos + t) : -1
        }

        scale() {
            const t = this.bb.__offset(this.bb_pos, 16);
            return t ? this.bb.readInt32(this.bb_pos + t) : -1
        }

        nullable() {
            const t = this.bb.__offset(this.bb_pos, 18);
            return !t || !!this.bb.readInt8(this.bb_pos + t)
        }

        unique() {
            const t = this.bb.__offset(this.bb_pos, 20);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        primaryKey() {
            const t = this.bb.__offset(this.bb_pos, 22);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        metadata(t) {
            const e = this.bb.__offset(this.bb_pos, 24);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        static startColumn(t) {
            t.startObject(11)
        }

        static addName(t, e) {
            t.addFieldOffset(0, e, 0)
        }

        static addType(t, e) {
            t.addFieldInt8(1, e, P.Byte)
        }

        static addTitle(t, e) {
            t.addFieldOffset(2, e, 0)
        }

        static addDescription(t, e) {
            t.addFieldOffset(3, e, 0)
        }

        static addWidth(t, e) {
            t.addFieldInt32(4, e, -1)
        }

        static addPrecision(t, e) {
            t.addFieldInt32(5, e, -1)
        }

        static addScale(t, e) {
            t.addFieldInt32(6, e, -1)
        }

        static addNullable(t, e) {
            t.addFieldInt8(7, +e, 1)
        }

        static addUnique(t, e) {
            t.addFieldInt8(8, +e, 0)
        }

        static addPrimaryKey(t, e) {
            t.addFieldInt8(9, +e, 0)
        }

        static addMetadata(t, e) {
            t.addFieldOffset(10, e, 0)
        }

        static endColumn(t) {
            const e = t.endObject();
            return t.requiredField(e, 4), e
        }

        static createColumn(t, e, r, n, s, i, o, a, h, u, c, l) {
            return E.startColumn(t), E.addName(t, e), E.addType(t, r), E.addTitle(t, n), E.addDescription(t, s), E.addWidth(t, i), E.addPrecision(t, o), E.addScale(t, a), E.addNullable(t, h), E.addUnique(t, u), E.addPrimaryKey(t, c), E.addMetadata(t, l), E.endColumn(t)
        }
    }

    class V {
        constructor() {
            this.bb = null, this.bb_pos = 0
        }

        __init(t, e) {
            return this.bb_pos = t, this.bb = e, this
        }

        static getRootAsCrs(t, e) {
            return (e || new V).__init(t.readInt32(t.position()) + t.position(), t)
        }

        static getSizePrefixedRootAsCrs(t, e) {
            return t.setPosition(t.position() + 4), (e || new V).__init(t.readInt32(t.position()) + t.position(), t)
        }

        org(t) {
            const e = this.bb.__offset(this.bb_pos, 4);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        code() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? this.bb.readInt32(this.bb_pos + t) : 0
        }

        name(t) {
            const e = this.bb.__offset(this.bb_pos, 8);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        description(t) {
            const e = this.bb.__offset(this.bb_pos, 10);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        wkt(t) {
            const e = this.bb.__offset(this.bb_pos, 12);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        codeString(t) {
            const e = this.bb.__offset(this.bb_pos, 14);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        static startCrs(t) {
            t.startObject(6)
        }

        static addOrg(t, e) {
            t.addFieldOffset(0, e, 0)
        }

        static addCode(t, e) {
            t.addFieldInt32(1, e, 0)
        }

        static addName(t, e) {
            t.addFieldOffset(2, e, 0)
        }

        static addDescription(t, e) {
            t.addFieldOffset(3, e, 0)
        }

        static addWkt(t, e) {
            t.addFieldOffset(4, e, 0)
        }

        static addCodeString(t, e) {
            t.addFieldOffset(5, e, 0)
        }

        static endCrs(t) {
            return t.endObject()
        }

        static createCrs(t, e, r, n, s, i, o) {
            return V.startCrs(t), V.addOrg(t, e), V.addCode(t, r), V.addName(t, n), V.addDescription(t, s), V.addWkt(t, i), V.addCodeString(t, o), V.endCrs(t)
        }
    }

    !function (t) {
        t[t.Unknown = 0] = "Unknown", t[t.Point = 1] = "Point", t[t.LineString = 2] = "LineString", t[t.Polygon = 3] = "Polygon", t[t.MultiPoint = 4] = "MultiPoint", t[t.MultiLineString = 5] = "MultiLineString", t[t.MultiPolygon = 6] = "MultiPolygon", t[t.GeometryCollection = 7] = "GeometryCollection", t[t.CircularString = 8] = "CircularString", t[t.CompoundCurve = 9] = "CompoundCurve", t[t.CurvePolygon = 10] = "CurvePolygon", t[t.MultiCurve = 11] = "MultiCurve", t[t.MultiSurface = 12] = "MultiSurface", t[t.Curve = 13] = "Curve", t[t.Surface = 14] = "Surface", t[t.PolyhedralSurface = 15] = "PolyhedralSurface", t[t.TIN = 16] = "TIN", t[t.Triangle = 17] = "Triangle"
    }(x || (x = {}));

    class A {
        constructor() {
            this.bb = null, this.bb_pos = 0
        }

        __init(t, e) {
            return this.bb_pos = t, this.bb = e, this
        }

        static getRootAsHeader(t, e) {
            return (e || new A).__init(t.readInt32(t.position()) + t.position(), t)
        }

        static getSizePrefixedRootAsHeader(t, e) {
            return t.setPosition(t.position() + 4), (e || new A).__init(t.readInt32(t.position()) + t.position(), t)
        }

        name(t) {
            const e = this.bb.__offset(this.bb_pos, 4);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        envelope(t) {
            const e = this.bb.__offset(this.bb_pos, 6);
            return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
        }

        envelopeLength() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        envelopeArray() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        geometryType() {
            const t = this.bb.__offset(this.bb_pos, 8);
            return t ? this.bb.readUint8(this.bb_pos + t) : x.Unknown
        }

        hasZ() {
            const t = this.bb.__offset(this.bb_pos, 10);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        hasM() {
            const t = this.bb.__offset(this.bb_pos, 12);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        hasT() {
            const t = this.bb.__offset(this.bb_pos, 14);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        hasTm() {
            const t = this.bb.__offset(this.bb_pos, 16);
            return !!t && !!this.bb.readInt8(this.bb_pos + t)
        }

        columns(t, e) {
            const r = this.bb.__offset(this.bb_pos, 18);
            return r ? (e || new E).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null
        }

        columnsLength() {
            const t = this.bb.__offset(this.bb_pos, 18);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        featuresCount() {
            const t = this.bb.__offset(this.bb_pos, 20);
            return t ? this.bb.readUint64(this.bb_pos + t) : this.bb.createLong(0, 0)
        }

        indexNodeSize() {
            const t = this.bb.__offset(this.bb_pos, 22);
            return t ? this.bb.readUint16(this.bb_pos + t) : 16
        }

        crs(t) {
            const e = this.bb.__offset(this.bb_pos, 24);
            return e ? (t || new V).__init(this.bb.__indirect(this.bb_pos + e), this.bb) : null
        }

        title(t) {
            const e = this.bb.__offset(this.bb_pos, 26);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        description(t) {
            const e = this.bb.__offset(this.bb_pos, 28);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        metadata(t) {
            const e = this.bb.__offset(this.bb_pos, 30);
            return e ? this.bb.__string(this.bb_pos + e, t) : null
        }

        static startHeader(t) {
            t.startObject(14)
        }

        static addName(t, e) {
            t.addFieldOffset(0, e, 0)
        }

        static addEnvelope(t, e) {
            t.addFieldOffset(1, e, 0)
        }

        static createEnvelopeVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addFloat64(e[r]);
            return t.endVector()
        }

        static startEnvelopeVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addGeometryType(t, e) {
            t.addFieldInt8(2, e, x.Unknown)
        }

        static addHasZ(t, e) {
            t.addFieldInt8(3, +e, 0)
        }

        static addHasM(t, e) {
            t.addFieldInt8(4, +e, 0)
        }

        static addHasT(t, e) {
            t.addFieldInt8(5, +e, 0)
        }

        static addHasTm(t, e) {
            t.addFieldInt8(6, +e, 0)
        }

        static addColumns(t, e) {
            t.addFieldOffset(7, e, 0)
        }

        static createColumnsVector(t, e) {
            t.startVector(4, e.length, 4);
            for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r]);
            return t.endVector()
        }

        static startColumnsVector(t, e) {
            t.startVector(4, e, 4)
        }

        static addFeaturesCount(t, e) {
            t.addFieldInt64(8, e, t.createLong(0, 0))
        }

        static addIndexNodeSize(t, e) {
            t.addFieldInt16(9, e, 16)
        }

        static addCrs(t, e) {
            t.addFieldOffset(10, e, 0)
        }

        static addTitle(t, e) {
            t.addFieldOffset(11, e, 0)
        }

        static addDescription(t, e) {
            t.addFieldOffset(12, e, 0)
        }

        static addMetadata(t, e) {
            t.addFieldOffset(13, e, 0)
        }

        static endHeader(t) {
            return t.endObject()
        }

        static finishHeaderBuffer(t, e) {
            t.finish(e)
        }

        static finishSizePrefixedHeaderBuffer(t, e) {
            t.finish(e, void 0, !0)
        }
    }

    class T {
        constructor() {
            this.bb = null, this.bb_pos = 0
        }

        __init(t, e) {
            return this.bb_pos = t, this.bb = e, this
        }

        static getRootAsGeometry(t, e) {
            return (e || new T).__init(t.readInt32(t.position()) + t.position(), t)
        }

        static getSizePrefixedRootAsGeometry(t, e) {
            return t.setPosition(t.position() + 4), (e || new T).__init(t.readInt32(t.position()) + t.position(), t)
        }

        ends(t) {
            const e = this.bb.__offset(this.bb_pos, 4);
            return e ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0
        }

        endsLength() {
            const t = this.bb.__offset(this.bb_pos, 4);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        endsArray() {
            const t = this.bb.__offset(this.bb_pos, 4);
            return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        xy(t) {
            const e = this.bb.__offset(this.bb_pos, 6);
            return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
        }

        xyLength() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        xyArray() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        z(t) {
            const e = this.bb.__offset(this.bb_pos, 8);
            return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
        }

        zLength() {
            const t = this.bb.__offset(this.bb_pos, 8);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        zArray() {
            const t = this.bb.__offset(this.bb_pos, 8);
            return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        m(t) {
            const e = this.bb.__offset(this.bb_pos, 10);
            return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
        }

        mLength() {
            const t = this.bb.__offset(this.bb_pos, 10);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        mArray() {
            const t = this.bb.__offset(this.bb_pos, 10);
            return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        t(t) {
            const e = this.bb.__offset(this.bb_pos, 12);
            return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
        }

        tLength() {
            const t = this.bb.__offset(this.bb_pos, 12);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        tArray() {
            const t = this.bb.__offset(this.bb_pos, 12);
            return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        tm(t) {
            const e = this.bb.__offset(this.bb_pos, 14);
            return e ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0)
        }

        tmLength() {
            const t = this.bb.__offset(this.bb_pos, 14);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        type() {
            const t = this.bb.__offset(this.bb_pos, 16);
            return t ? this.bb.readUint8(this.bb_pos + t) : x.Unknown
        }

        parts(t, e) {
            const r = this.bb.__offset(this.bb_pos, 18);
            return r ? (e || new T).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null
        }

        partsLength() {
            const t = this.bb.__offset(this.bb_pos, 18);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        static startGeometry(t) {
            t.startObject(8)
        }

        static addEnds(t, e) {
            t.addFieldOffset(0, e, 0)
        }

        static createEndsVector(t, e) {
            t.startVector(4, e.length, 4);
            for (let r = e.length - 1; r >= 0; r--) t.addInt32(e[r]);
            return t.endVector()
        }

        static startEndsVector(t, e) {
            t.startVector(4, e, 4)
        }

        static addXy(t, e) {
            t.addFieldOffset(1, e, 0)
        }

        static createXyVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addFloat64(e[r]);
            return t.endVector()
        }

        static startXyVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addZ(t, e) {
            t.addFieldOffset(2, e, 0)
        }

        static createZVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addFloat64(e[r]);
            return t.endVector()
        }

        static startZVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addM(t, e) {
            t.addFieldOffset(3, e, 0)
        }

        static createMVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addFloat64(e[r]);
            return t.endVector()
        }

        static startMVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addT(t, e) {
            t.addFieldOffset(4, e, 0)
        }

        static createTVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addFloat64(e[r]);
            return t.endVector()
        }

        static startTVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addTm(t, e) {
            t.addFieldOffset(5, e, 0)
        }

        static createTmVector(t, e) {
            t.startVector(8, e.length, 8);
            for (let r = e.length - 1; r >= 0; r--) t.addInt64(e[r]);
            return t.endVector()
        }

        static startTmVector(t, e) {
            t.startVector(8, e, 8)
        }

        static addType(t, e) {
            t.addFieldInt8(6, e, x.Unknown)
        }

        static addParts(t, e) {
            t.addFieldOffset(7, e, 0)
        }

        static createPartsVector(t, e) {
            t.startVector(4, e.length, 4);
            for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r]);
            return t.endVector()
        }

        static startPartsVector(t, e) {
            t.startVector(4, e, 4)
        }

        static endGeometry(t) {
            return t.endObject()
        }

        static createGeometry(t, e, r, n, s, i, o, a, h) {
            return T.startGeometry(t), T.addEnds(t, e), T.addXy(t, r), T.addZ(t, n), T.addM(t, s), T.addT(t, i), T.addTm(t, o), T.addType(t, a), T.addParts(t, h), T.endGeometry(t)
        }
    }

    class B {
        constructor() {
            this.bb = null, this.bb_pos = 0
        }

        __init(t, e) {
            return this.bb_pos = t, this.bb = e, this
        }

        static getRootAsFeature(t, e) {
            return (e || new B).__init(t.readInt32(t.position()) + t.position(), t)
        }

        static getSizePrefixedRootAsFeature(t, e) {
            return t.setPosition(t.position() + 4), (e || new B).__init(t.readInt32(t.position()) + t.position(), t)
        }

        geometry(t) {
            const e = this.bb.__offset(this.bb_pos, 4);
            return e ? (t || new T).__init(this.bb.__indirect(this.bb_pos + e), this.bb) : null
        }

        properties(t) {
            const e = this.bb.__offset(this.bb_pos, 6);
            return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0
        }

        propertiesLength() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        propertiesArray() {
            const t = this.bb.__offset(this.bb_pos, 6);
            return t ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
        }

        columns(t, e) {
            const r = this.bb.__offset(this.bb_pos, 8);
            return r ? (e || new E).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null
        }

        columnsLength() {
            const t = this.bb.__offset(this.bb_pos, 8);
            return t ? this.bb.__vector_len(this.bb_pos + t) : 0
        }

        static startFeature(t) {
            t.startObject(3)
        }

        static addGeometry(t, e) {
            t.addFieldOffset(0, e, 0)
        }

        static addProperties(t, e) {
            t.addFieldOffset(1, e, 0)
        }

        static createPropertiesVector(t, e) {
            t.startVector(1, e.length, 1);
            for (let r = e.length - 1; r >= 0; r--) t.addInt8(e[r]);
            return t.endVector()
        }

        static startPropertiesVector(t, e) {
            t.startVector(1, e, 1)
        }

        static addColumns(t, e) {
            t.addFieldOffset(2, e, 0)
        }

        static createColumnsVector(t, e) {
            t.startVector(4, e.length, 4);
            for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r]);
            return t.endVector()
        }

        static startColumnsVector(t, e) {
            t.startVector(4, e, 4)
        }

        static endFeature(t) {
            return t.endObject()
        }

        static finishFeatureBuffer(t, e) {
            t.finish(e)
        }

        static finishSizePrefixedFeatureBuffer(t, e) {
            t.finish(e, void 0, !0)
        }

        static createFeature(t, e, r, n) {
            return B.startFeature(t), B.addGeometry(t, e), B.addProperties(t, r), B.addColumns(t, n), B.endFeature(t)
        }
    }

    class k {
        constructor(t, e, r, n, s, i) {
            this.org = t, this.code = e, this.name = r, this.description = n, this.wkt = s, this.code_string = i
        }
    }

    class L {
        constructor(t, e, r, n, s, i, o, a) {
            this.geometryType = t, this.columns = e, this.featuresCount = r, this.indexNodeSize = n, this.crs = s, this.title = i, this.description = o, this.metadata = a
        }

        static fromByteBuffer(t) {
            const e = A.getRootAsHeader(t), r = e.featuresCount().toFloat64(), n = e.indexNodeSize(), s = [];
            for (let t = 0; t < e.columnsLength(); t++) {
                const r = e.columns(t);
                if (!r) throw new Error("Column unexpectedly missing");
                if (!r.name()) throw new Error("Column name unexpectedly missing");
                s.push(new C(r.name(), r.type(), r.title(), r.description(), r.width(), r.precision(), r.scale(), r.nullable(), r.unique(), r.primaryKey()))
            }
            const i = e.crs(),
                o = i ? new k(i.org(), i.code(), i.name(), i.description(), i.wkt(), i.codeString()) : null;
            return new L(e.geometryType(), s, r, n, o, e.title(), e.description(), e.metadata())
        }
    }

    function q(t, e) {
        const {xy: r, z: n, ends: s, parts: i, type: o} = e;
        if (i) {
            const e = i.map((e => q(t, e))), r = T.createPartsVector(t, e);
            return T.startGeometry(t), T.addParts(t, r), T.addType(t, o), T.endGeometry(t)
        }
        const a = T.createXyVector(t, r);
        let h, u;
        return n && (h = T.createZVector(t, n)), s && (u = T.createEndsVector(t, s)), T.startGeometry(t), u && T.addEnds(t, u), T.addXy(t, a), h && T.addZ(t, h), T.addType(t, o), T.endGeometry(t)
    }

    function j(t, e) {
        let r, n, s, i = e;
        if (i === x.Unknown && (i = M(t.getType())), i === x.MultiLineString) {
            t.getFlatCoordinates && (r = t.getFlatCoordinates());
            const e = t.getEnds();
            e.length > 1 && (n = e.map((t => t >> 1)))
        } else if (i === x.Polygon) {
            t.getFlatCoordinates && (r = t.getFlatCoordinates());
            const e = t.getEnds();
            e.length > 1 && (n = e.map((t => t >> 1)))
        } else if (i === x.MultiPolygon) {
            s = t.getPolygons().map((t => j(t, x.Polygon)))
        } else t.getFlatCoordinates && (r = t.getFlatCoordinates());
        return {xy: r, ends: n, type: i, parts: s}
    }

    function M(t) {
        if (!t) return x.Unknown;
        return x[t]
    }

    const N = new TextEncoder, R = new TextDecoder;

    function $(t, e, r, n) {
        const s = e.columns, i = r(t.geometry(), e.geometryType), o = function (t, e) {
            const r = {};
            if (!e || 0 === e.length) return r;
            const n = t.propertiesArray();
            if (!n) return r;
            const s = new DataView(n.buffer, n.byteOffset), i = t.propertiesLength();
            let o = 0;
            for (; o < i;) {
                const t = s.getUint16(o, !0);
                o += 2;
                const i = e[t], a = i.name;
                switch (i.type) {
                    case P.Bool:
                        r[a] = !!s.getUint8(o), o += 1;
                        break;
                    case P.Byte:
                        r[a] = s.getInt8(o), o += 1;
                        break;
                    case P.UByte:
                        r[a] = s.getUint8(o), o += 1;
                        break;
                    case P.Short:
                        r[a] = s.getInt16(o, !0), o += 2;
                        break;
                    case P.UShort:
                        r[a] = s.getUint16(o, !0), o += 2;
                        break;
                    case P.Int:
                        r[a] = s.getInt32(o, !0), o += 4;
                        break;
                    case P.UInt:
                        r[a] = s.getUint32(o, !0), o += 4;
                        break;
                    case P.Long:
                        r[a] = Number(s.getBigInt64(o, !0)), o += 8;
                        break;
                    case P.ULong:
                        r[a] = Number(s.getBigUint64(o, !0)), o += 8;
                        break;
                    case P.Double:
                        r[a] = s.getFloat64(o, !0), o += 8;
                        break;
                    case P.DateTime:
                    case P.String: {
                        const t = s.getUint32(o, !0);
                        o += 4, r[a] = R.decode(n.subarray(o, o + t)), o += t;
                        break
                    }
                    default:
                        throw new Error("Unknown type " + i.type)
                }
            }
            return r
        }
            /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.

        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.

        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */(t, s);
        return n(i, o)
    }

    function z(t, e, r) {
        const n = r.columns, s = new F;
        let i = 0, o = 1024, a = new Uint8Array(o), h = new DataView(a.buffer);
        const u = function (t) {
            if (i + t < o) return;
            o *= 2;
            const e = new Uint8Array(o);
            e.set(a), a = e, h = new DataView(a.buffer, i)
        };
        if (n) for (let t = 0; t < n.length; t++) {
            const r = n[t], s = e[r.name];
            if (null !== s) switch (h.setUint16(i, t, !0), i += 2, r.type) {
                case P.Bool:
                    u(1), h.setUint8(i, s), i += 1;
                    break;
                case P.Short:
                    u(2), h.setInt16(i, s, !0), i += 2;
                    break;
                case P.UShort:
                    u(2), h.setUint16(i, s, !0), i += 2;
                    break;
                case P.Int:
                    u(4), h.setInt32(i, s, !0), i += 4;
                    break;
                case P.UInt:
                    u(4), h.setUint32(i, s, !0), i += 4;
                    break;
                case P.Long:
                    u(8), h.setBigInt64(i, BigInt(s), !0), i += 8;
                    break;
                case P.Double:
                    u(8), h.setFloat64(i, s, !0), i += 8;
                    break;
                case P.DateTime:
                case P.String: {
                    const t = N.encode(s);
                    u(4), h.setUint32(i, t.length, !0), i += 4, u(t.length), a.set(t, i), i += t.length;
                    break
                }
                default:
                    throw new Error("Unknown type " + r.type)
            }
        }
        let c = null;
        i > 0 && (c = B.createPropertiesVector(s, a.slice(0, i)));
        const l = q(s, t);
        B.startFeature(s), B.addGeometry(s, l), c && B.addProperties(s, c);
        const b = B.endFeature(s);
        return s.finishSizePrefixed(b), s.asUint8Array()
    }

    var G = function (t, e) {
        return G = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (t, e) {
            t.__proto__ = e
        } || function (t, e) {
            for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r])
        }, G(t, e)
    };

    function D(t, e, r, n) {
        return new (r || (r = Promise))((function (s, i) {
            function o(t) {
                try {
                    h(n.next(t))
                } catch (t) {
                    i(t)
                }
            }

            function a(t) {
                try {
                    h(n.throw(t))
                } catch (t) {
                    i(t)
                }
            }

            function h(t) {
                var e;
                t.done ? s(t.value) : (e = t.value, e instanceof r ? e : new r((function (t) {
                    t(e)
                }))).then(o, a)
            }

            h((n = n.apply(t, e || [])).next())
        }))
    }

    function H(t, e) {
        var r, n, s, i, o = {
            label: 0, sent: function () {
                if (1 & s[0]) throw s[1];
                return s[1]
            }, trys: [], ops: []
        };
        return i = {
            next: a(0),
            throw: a(1),
            return: a(2)
        }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
            return this
        }), i;

        function a(i) {
            return function (a) {
                return function (i) {
                    if (r) throw new TypeError("Generator is already executing.");
                    for (; o;) try {
                        if (r = 1, n && (s = 2 & i[0] ? n.return : i[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, i[1])).done) return s;
                        switch (n = 0, s && (i = [2 & i[0], s.value]), i[0]) {
                            case 0:
                            case 1:
                                s = i;
                                break;
                            case 4:
                                return o.label++, {value: i[1], done: !1};
                            case 5:
                                o.label++, n = i[1], i = [0];
                                continue;
                            case 7:
                                i = o.ops.pop(), o.trys.pop();
                                continue;
                            default:
                                if (!(s = o.trys, (s = s.length > 0 && s[s.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                    o = 0;
                                    continue
                                }
                                if (3 === i[0] && (!s || i[1] > s[0] && i[1] < s[3])) {
                                    o.label = i[1];
                                    break
                                }
                                if (6 === i[0] && o.label < s[1]) {
                                    o.label = s[1], s = i;
                                    break
                                }
                                if (s && o.label < s[2]) {
                                    o.label = s[2], o.ops.push(i);
                                    break
                                }
                                s[2] && o.ops.pop(), o.trys.pop();
                                continue
                        }
                        i = e.call(t, o)
                    } catch (t) {
                        i = [6, t], n = 0
                    } finally {
                        r = s = 0
                    }
                    if (5 & i[0]) throw i[1];
                    return {value: i[0] ? i[1] : void 0, done: !0}
                }([i, a])
            }
        }
    }

    function W(t) {
        var e = "function" == typeof Symbol && Symbol.iterator, r = e && t[e], n = 0;
        if (r) return r.call(t);
        if (t && "number" == typeof t.length) return {
            next: function () {
                return t && n >= t.length && (t = void 0), {value: t && t[n++], done: !t}
            }
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }

    function X(t) {
        return this instanceof X ? (this.v = t, this) : new X(t)
    }

    function Z(t, e, r) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var n, s = r.apply(t, e || []), i = [];
        return n = {}, o("next"), o("throw"), o("return"), n[Symbol.asyncIterator] = function () {
            return this
        }, n;

        function o(t) {
            s[t] && (n[t] = function (e) {
                return new Promise((function (r, n) {
                    i.push([t, e, r, n]) > 1 || a(t, e)
                }))
            })
        }

        function a(t, e) {
            try {
                (r = s[t](e)).value instanceof X ? Promise.resolve(r.value.v).then(h, u) : c(i[0][2], r)
            } catch (t) {
                c(i[0][3], t)
            }
            var r
        }

        function h(t) {
            a("next", t)
        }

        function u(t) {
            a("throw", t)
        }

        function c(t, e) {
            t(e), i.shift(), i.length && a(i[0][0], i[0][1])
        }
    }

    var Y = function (t) {
        function e(e) {
            var r = t.call(this, e) || this;
            return Object.defineProperty(r, "name", {
                value: "RepeaterOverflowError",
                enumerable: !1
            }), "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf(r, r.constructor.prototype) : r.__proto__ = r.constructor.prototype, "function" == typeof Error.captureStackTrace && Error.captureStackTrace(r, r.constructor), r
        }

        return function (t, e) {
            function r() {
                this.constructor = t
            }

            G(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r)
        }(e, t), e
    }(Error);

    function K(t) {
        null != t && "function" == typeof t.then && t.then(Q, Q)
    }

    !function () {
        function t(t) {
            if (t < 0) throw new RangeError("Capacity may not be less than 0");
            this._c = t, this._q = []
        }

        Object.defineProperty(t.prototype, "empty", {
            get: function () {
                return 0 === this._q.length
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(t.prototype, "full", {
            get: function () {
                return this._q.length >= this._c
            }, enumerable: !1, configurable: !0
        }), t.prototype.add = function (t) {
            if (this.full) throw new Error("Buffer full");
            this._q.push(t)
        }, t.prototype.remove = function () {
            if (this.empty) throw new Error("Buffer empty");
            return this._q.shift()
        }
    }(), function () {
        function t(t) {
            if (t < 1) throw new RangeError("Capacity may not be less than 1");
            this._c = t, this._q = []
        }

        Object.defineProperty(t.prototype, "empty", {
            get: function () {
                return 0 === this._q.length
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(t.prototype, "full", {
            get: function () {
                return !1
            }, enumerable: !1, configurable: !0
        }), t.prototype.add = function (t) {
            for (; this._q.length >= this._c;) this._q.shift();
            this._q.push(t)
        }, t.prototype.remove = function () {
            if (this.empty) throw new Error("Buffer empty");
            return this._q.shift()
        }
    }(), function () {
        function t(t) {
            if (t < 1) throw new RangeError("Capacity may not be less than 1");
            this._c = t, this._q = []
        }

        Object.defineProperty(t.prototype, "empty", {
            get: function () {
                return 0 === this._q.length
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(t.prototype, "full", {
            get: function () {
                return !1
            }, enumerable: !1, configurable: !0
        }), t.prototype.add = function (t) {
            this._q.length < this._c && this._q.push(t)
        }, t.prototype.remove = function () {
            if (this.empty) throw new Error("Buffer empty");
            return this._q.shift()
        }
    }();
    var J = 1024, Q = function () {
    };

    function tt(t) {
        var e = t.err, r = Promise.resolve(t.execution).then((function (t) {
            if (null != e) throw e;
            return t
        }));
        return t.err = void 0, t.execution = r.then((function () {
        }), (function () {
        })), void 0 === t.pending ? r : t.pending.then((function () {
            return r
        }))
    }

    function et(t, e) {
        var r = t.state >= 3;
        return Promise.resolve(e).then((function (e) {
            return !r && t.state >= 4 ? tt(t).then((function (t) {
                return {value: t, done: !0}
            })) : {value: e, done: r}
        }))
    }

    function rt(t, e) {
        var r, n;
        if (!(t.state >= 2)) if (t.state = 2, t.onnext(), t.onstop(), null == t.err && (t.err = e), 0 !== t.pushes.length || void 0 !== t.buffer && !t.buffer.empty) try {
            for (var s = W(t.pushes), i = s.next(); !i.done; i = s.next()) {
                i.value.resolve()
            }
        } catch (t) {
            r = {error: t}
        } finally {
            try {
                i && !i.done && (n = s.return) && n.call(s)
            } finally {
                if (r) throw r.error
            }
        } else nt(t)
    }

    function nt(t) {
        var e, r;
        if (!(t.state >= 3)) {
            t.state < 2 && rt(t), t.state = 3, t.buffer = void 0;
            try {
                for (var n = W(t.nexts), s = n.next(); !s.done; s = n.next()) {
                    var i = s.value, o = void 0 === t.pending ? tt(t) : t.pending.then((function () {
                        return tt(t)
                    }));
                    i.resolve(et(t, o))
                }
            } catch (t) {
                e = {error: t}
            } finally {
                try {
                    s && !s.done && (r = n.return) && r.call(n)
                } finally {
                    if (e) throw e.error
                }
            }
            t.pushes = [], t.nexts = []
        }
    }

    function st(t) {
        t.state >= 4 || (t.state < 3 && nt(t), t.state = 4)
    }

    function it(t, e) {
        if (K(e), t.pushes.length >= J) throw new Y("No more than 1024 pending calls to push are allowed on a single repeater.");
        if (t.state >= 2) return Promise.resolve(void 0);
        var r, n = void 0 === t.pending ? Promise.resolve(e) : t.pending.then((function () {
            return e
        }));
        (n = n.catch((function (e) {
            t.state < 2 && (t.err = e), st(t)
        })), t.nexts.length) ? (t.nexts.shift().resolve(et(t, n)), r = t.nexts.length ? Promise.resolve(t.nexts[0].value) : new Promise((function (e) {
            return t.onnext = e
        }))) : void 0 === t.buffer || t.buffer.full ? r = new Promise((function (e) {
            return t.pushes.push({resolve: e, value: n})
        })) : (t.buffer.add(n), r = Promise.resolve(void 0));
        var s = !0, i = {}, o = r.catch((function (t) {
            if (s) throw t
        }));
        return i.then = function (t, e) {
            return s = !1, Promise.prototype.then.call(r, t, e)
        }, i.catch = function (t) {
            return s = !1, Promise.prototype.catch.call(r, t)
        }, i.finally = r.finally.bind(r), t.pending = n.then((function () {
            return o
        })).catch((function (e) {
            t.err = e, st(t)
        })), i
    }

    function ot(t) {
        if (!(t.state >= 1)) {
            t.state = 1;
            var e = it.bind(null, t), r = function (t) {
                var e = rt.bind(null, t), r = new Promise((function (e) {
                    return t.onstop = e
                }));
                return e.then = r.then.bind(r), e.catch = r.catch.bind(r), e.finally = r.finally.bind(r), e
            }(t);
            t.execution = new Promise((function (n) {
                return n(t.executor(e, r))
            })), t.execution.catch((function () {
                return rt(t)
            }))
        }
    }

    var at, ht = new WeakMap, ut = function () {
        function t(t, e) {
            ht.set(this, {
                executor: t,
                buffer: e,
                err: void 0,
                state: 0,
                pushes: [],
                nexts: [],
                pending: void 0,
                execution: void 0,
                onnext: Q,
                onstop: Q
            })
        }

        return t.prototype.next = function (t) {
            K(t);
            var e = ht.get(this);
            if (void 0 === e) throw new Error("WeakMap error");
            if (e.nexts.length >= J) throw new Y("No more than 1024 pending calls to next are allowed on a single repeater.");
            if (e.state <= 0 && ot(e), e.onnext(t), void 0 !== e.buffer && !e.buffer.empty) {
                var r = et(e, e.buffer.remove());
                if (e.pushes.length) {
                    var n = e.pushes.shift();
                    e.buffer.add(n.value), e.onnext = n.resolve
                }
                return r
            }
            if (e.pushes.length) {
                var s = e.pushes.shift();
                return e.onnext = s.resolve, et(e, s.value)
            }
            return e.state >= 2 ? (nt(e), et(e, tt(e))) : new Promise((function (r) {
                return e.nexts.push({resolve: r, value: t})
            }))
        }, t.prototype.return = function (t) {
            K(t);
            var e = ht.get(this);
            if (void 0 === e) throw new Error("WeakMap error");
            return nt(e), e.execution = Promise.resolve(e.execution).then((function () {
                return t
            })), et(e, tt(e))
        }, t.prototype.throw = function (t) {
            var e = ht.get(this);
            if (void 0 === e) throw new Error("WeakMap error");
            return e.state <= 0 || e.state >= 2 || void 0 !== e.buffer && !e.buffer.empty ? (nt(e), null == e.err && (e.err = t), et(e, tt(e))) : this.next(Promise.reject(t))
        }, t.prototype[Symbol.asyncIterator] = function () {
            return this
        }, t.race = lt, t.merge = bt, t.zip = ft, t.latest = dt, t
    }();

    function ct(t, e) {
        var r, n, s = [], i = function (t) {
            null != t && "function" == typeof t[Symbol.asyncIterator] ? s.push(t[Symbol.asyncIterator]()) : null != t && "function" == typeof t[Symbol.iterator] ? s.push(t[Symbol.iterator]()) : s.push(function () {
                return Z(this, arguments, (function () {
                    return H(this, (function (r) {
                        switch (r.label) {
                            case 0:
                                return e.yieldValues ? [4, X(t)] : [3, 3];
                            case 1:
                                return [4, r.sent()];
                            case 2:
                                r.sent(), r.label = 3;
                            case 3:
                                return e.returnValues ? [4, X(t)] : [3, 5];
                            case 4:
                                return [2, r.sent()];
                            case 5:
                                return [2]
                        }
                    }))
                }))
            }())
        };
        try {
            for (var o = W(t), a = o.next(); !a.done; a = o.next()) {
                i(a.value)
            }
        } catch (t) {
            r = {error: t}
        } finally {
            try {
                a && !a.done && (n = o.return) && n.call(o)
            } finally {
                if (r) throw r.error
            }
        }
        return s
    }

    function lt(t) {
        var e = this, r = ct(t, {returnValues: !0});
        return new ut((function (t, n) {
            return D(e, void 0, void 0, (function () {
                var e, s, i, o, a, h;
                return H(this, (function (u) {
                    switch (u.label) {
                        case 0:
                            if (!r.length) return n(), [2];
                            s = !1, n.then((function () {
                                e(), s = !0
                            })), u.label = 1;
                        case 1:
                            u.trys.push([1, , 5, 7]), o = void 0, a = 0, h = function () {
                                var s, h, u, c, l, b;
                                return H(this, (function (f) {
                                    switch (f.label) {
                                        case 0:
                                            s = a;
                                            try {
                                                for (l = void 0, h = W(r), u = h.next(); !u.done; u = h.next()) c = u.value, Promise.resolve(c.next()).then((function (t) {
                                                    t.done ? (n(), void 0 === i && (i = t)) : a === s && (a++, e(t))
                                                }), (function (t) {
                                                    return n(t)
                                                }))
                                            } catch (t) {
                                                l = {error: t}
                                            } finally {
                                                try {
                                                    u && !u.done && (b = h.return) && b.call(h)
                                                } finally {
                                                    if (l) throw l.error
                                                }
                                            }
                                            return [4, new Promise((function (t) {
                                                return e = t
                                            }))];
                                        case 1:
                                            return void 0 === (o = f.sent()) ? [3, 3] : [4, t(o.value)];
                                        case 2:
                                            f.sent(), f.label = 3;
                                        case 3:
                                            return [2]
                                    }
                                }))
                            }, u.label = 2;
                        case 2:
                            return s ? [3, 4] : [5, h()];
                        case 3:
                            return u.sent(), [3, 2];
                        case 4:
                            return [2, i && i.value];
                        case 5:
                            return n(), [4, Promise.race(r.map((function (t) {
                                return t.return && t.return()
                            })))];
                        case 6:
                            return u.sent(), [7];
                        case 7:
                            return [2]
                    }
                }))
            }))
        }))
    }

    function bt(t) {
        var e = this, r = ct(t, {yieldValues: !0});
        return new ut((function (t, n) {
            return D(e, void 0, void 0, (function () {
                var e, s, i, o = this;
                return H(this, (function (a) {
                    switch (a.label) {
                        case 0:
                            if (!r.length) return n(), [2];
                            e = [], s = !1, n.then((function () {
                                var t, r;
                                s = !0;
                                try {
                                    for (var n = W(e), i = n.next(); !i.done; i = n.next()) {
                                        (0, i.value)()
                                    }
                                } catch (e) {
                                    t = {error: e}
                                } finally {
                                    try {
                                        i && !i.done && (r = n.return) && r.call(n)
                                    } finally {
                                        if (t) throw t.error
                                    }
                                }
                            })), a.label = 1;
                        case 1:
                            return a.trys.push([1, , 3, 4]), [4, Promise.all(r.map((function (r, a) {
                                return D(o, void 0, void 0, (function () {
                                    var o;
                                    return H(this, (function (h) {
                                        switch (h.label) {
                                            case 0:
                                                h.trys.push([0, , 6, 9]), h.label = 1;
                                            case 1:
                                                return s ? [3, 5] : (Promise.resolve(r.next()).then((function (t) {
                                                    return e[a](t)
                                                }), (function (t) {
                                                    return n(t)
                                                })), [4, new Promise((function (t) {
                                                    e[a] = t
                                                }))]);
                                            case 2:
                                                return void 0 === (o = h.sent()) ? [3, 4] : o.done ? (i = o, [2]) : [4, t(o.value)];
                                            case 3:
                                                h.sent(), h.label = 4;
                                            case 4:
                                                return [3, 1];
                                            case 5:
                                                return [3, 9];
                                            case 6:
                                                return r.return ? [4, r.return()] : [3, 8];
                                            case 7:
                                                h.sent(), h.label = 8;
                                            case 8:
                                                return [7];
                                            case 9:
                                                return [2]
                                        }
                                    }))
                                }))
                            })))];
                        case 2:
                            return a.sent(), [2, i && i.value];
                        case 3:
                            return n(), [7];
                        case 4:
                            return [2]
                    }
                }))
            }))
        }))
    }

    function ft(t) {
        var e = this, r = ct(t, {returnValues: !0});
        return new ut((function (t, n) {
            return D(e, void 0, void 0, (function () {
                var e, s, i, o;
                return H(this, (function (a) {
                    switch (a.label) {
                        case 0:
                            if (!r.length) return n(), [2, []];
                            s = !1, n.then((function () {
                                e(), s = !0
                            })), a.label = 1;
                        case 1:
                            a.trys.push([1, , 6, 8]), a.label = 2;
                        case 2:
                            return s ? [3, 5] : (Promise.all(r.map((function (t) {
                                return t.next()
                            }))).then((function (t) {
                                return e(t)
                            }), (function (t) {
                                return n(t)
                            })), [4, new Promise((function (t) {
                                return e = t
                            }))]);
                        case 3:
                            return void 0 === (i = a.sent()) ? [2] : (o = i.map((function (t) {
                                return t.value
                            })), i.some((function (t) {
                                return t.done
                            })) ? [2, o] : [4, t(o)]);
                        case 4:
                            return a.sent(), [3, 2];
                        case 5:
                            return [3, 8];
                        case 6:
                            return n(), [4, Promise.all(r.map((function (t) {
                                return t.return && t.return()
                            })))];
                        case 7:
                            return a.sent(), [7];
                        case 8:
                            return [2]
                    }
                }))
            }))
        }))
    }

    function dt(t) {
        var e = this, r = ct(t, {yieldValues: !0, returnValues: !0});
        return new ut((function (t, n) {
            return D(e, void 0, void 0, (function () {
                var e, s, i, o, a, h = this;
                return H(this, (function (u) {
                    switch (u.label) {
                        case 0:
                            if (!r.length) return n(), [2, []];
                            s = [], i = !1, n.then((function () {
                                var t, r;
                                e();
                                try {
                                    for (var n = W(s), o = n.next(); !o.done; o = n.next()) {
                                        (0, o.value)()
                                    }
                                } catch (e) {
                                    t = {error: e}
                                } finally {
                                    try {
                                        o && !o.done && (r = n.return) && r.call(n)
                                    } finally {
                                        if (t) throw t.error
                                    }
                                }
                                i = !0
                            })), u.label = 1;
                        case 1:
                            return u.trys.push([1, , 5, 7]), Promise.all(r.map((function (t) {
                                return t.next()
                            }))).then((function (t) {
                                return e(t)
                            }), (function (t) {
                                return n(t)
                            })), [4, new Promise((function (t) {
                                return e = t
                            }))];
                        case 2:
                            return void 0 === (o = u.sent()) ? [2] : (a = o.map((function (t) {
                                return t.value
                            })), o.every((function (t) {
                                return t.done
                            })) ? [2, a] : [4, t(a.slice())]);
                        case 3:
                            return u.sent(), [4, Promise.all(r.map((function (e, r) {
                                return D(h, void 0, void 0, (function () {
                                    var h;
                                    return H(this, (function (u) {
                                        switch (u.label) {
                                            case 0:
                                                if (o[r].done) return [2, o[r].value];
                                                u.label = 1;
                                            case 1:
                                                return i ? [3, 4] : (Promise.resolve(e.next()).then((function (t) {
                                                    return s[r](t)
                                                }), (function (t) {
                                                    return n(t)
                                                })), [4, new Promise((function (t) {
                                                    return s[r] = t
                                                }))]);
                                            case 2:
                                                return void 0 === (h = u.sent()) ? [2, o[r].value] : h.done ? [2, h.value] : (a[r] = h.value, [4, t(a.slice())]);
                                            case 3:
                                                return u.sent(), [3, 1];
                                            case 4:
                                                return [2]
                                        }
                                    }))
                                }))
                            })))];
                        case 4:
                            return [2, u.sent()];
                        case 5:
                            return n(), [4, Promise.all(r.map((function (t) {
                                return t.return && t.return()
                            })))];
                        case 6:
                            return u.sent(), [7];
                        case 7:
                            return [2]
                    }
                }))
            }))
        }))
    }

    class _t {
        constructor() {
            this._extraRequestThreshold = 262144
        }

        extraRequestThreshold() {
            return this._extraRequestThreshold
        }

        setExtraRequestThreshold(t) {
            if (t < 0) throw new Error("extraRequestThreshold cannot be negative");
            this._extraRequestThreshold = t
        }
    }

    _t.global = new _t, function (t) {
        t[t.Debug = 0] = "Debug", t[t.Info = 1] = "Info", t[t.Warn = 2] = "Warn", t[t.Error = 3] = "Error"
    }(at || (at = {}));

    class pt {
        static debug() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
            this.log(at.Debug, ...e)
        }

        static info() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
            this.log(at.Info, ...e)
        }

        static warn() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
            this.log(at.Warn, ...e)
        }

        static error() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
            this.log(at.Error, ...e)
        }

        static log(t) {
            if (!(this.logLevel > t)) {
                for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];
                switch (t) {
                    case at.Debug:
                        console.debug(...r);
                        break;
                    case at.Info:
                        console.info(...r);
                        break;
                    case at.Warn:
                        console.warn(...r);
                        break;
                    case at.Error:
                        console.error(...r)
                }
            }
        }
    }

    pt.logLevel = at.Info;

    function yt(t, e) {
        e = Math.min(Math.max(+e, 2), 65535);
        let r = t, n = r;
        do {
            r = Math.ceil(r / e), n += r
        } while (1 !== r);
        return 40 * n
    }

    async function* gt(t, e, r, n) {
        class s {
            constructor(t, e) {
                this._level = e, this.nodes = t
            }

            level() {
                return this._level
            }

            startNode() {
                return this.nodes[0]
            }

            endNode() {
                return this.nodes[1]
            }

            extendEndNodeToNewOffset(t) {
                console.assert(t > this.nodes[1]), this.nodes[1] = t
            }

            toString() {
                return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`
            }
        }

        const {minX: i, minY: o, maxX: a, maxY: h} = r;
        pt.info(`tree items: ${t}, nodeSize: ${e}`);
        const u = function (t, e) {
            if (e < 2) throw new Error("Node size must be at least 2");
            if (0 === t) throw new Error("Number of items must be greater than 0");
            let r = t, n = r;
            const s = [r];
            do {
                r = Math.ceil(r / e), n += r, s.push(r)
            } while (1 !== r);
            const i = [];
            r = n;
            for (const t of s) i.push(r - t), r -= t;
            i.reverse(), s.reverse();
            const o = [];
            for (let t = 0; t < s.length; t++) o.push([i[t], i[t] + s[t]]);
            return o.reverse(), o
        }(t, e), c = u[0][0], l = [(() => {
            const t = u.length - 1;
            return new s([0, 1], t)
        })()];
        for (pt.debug(`starting stream search with queue: ${l}, numItems: ${t}, nodeSize: ${e}, levelBounds: ${u}`); 0 != l.length;) {
            const r = l.shift();
            pt.debug(`popped node: ${r}, queueLength: ${l.length}`);
            const b = r.startNode(), f = b >= c, [, d] = u[r.level()], _ = Math.min(r.endNode() + e, d), p = _ - b,
                y = await n(40 * b, 40 * p), g = new Float64Array(y), w = new Uint32Array(y);
            for (let e = b; e < _; e++) {
                const n = 5 * (e - b);
                if (a < g[n + 0]) continue;
                if (h < g[n + 1]) continue;
                if (i > g[n + 2]) continue;
                if (o > g[n + 3]) continue;
                const u = w[8 + (n << 1)], d = wt(w[9 + (n << 1)], u);
                if (f) {
                    const r = (() => {
                        if (e < t - 1) {
                            const t = 5 * (e - b + 1), r = w[8 + (t << 1)];
                            return wt(w[9 + (t << 1)], r) - d
                        }
                        return null
                    })();
                    yield[d, e - c, r];
                    continue
                }
                const _ = _t.global.extraRequestThreshold() / 40, p = l[l.length - 1];
                if (void 0 !== p && p.level() == r.level() - 1 && d < p.endNode() + _) {
                    pt.debug(`Merging "nodeRange" request into existing range: ${p}, newOffset: ${p.endNode()} -> ${d}`), p.extendEndNodeToNewOffset(d);
                    continue
                }
                const y = (() => {
                    const t = r.level() - 1;
                    return new s([d, d + 1], t)
                })();
                void 0 !== p && p.level() == y.level() ? pt.info(`Same level, but too far away. Pushing new request at offset: ${d} rather than merging with distant ${p}`) : pt.info(`Pushing new level for ${y} onto queue with nearestNodeRange: ${p} since there's not already a range for this level.`), l.push(y)
            }
        }
    }

    function wt(t, e) {
        if (0 != (4293918720 & t)) throw Error("integer is too large to be safely represented");
        return e + t * 2 ** 32
    }

    const mt = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]);

    class vt {
        constructor(t, e, r, n) {
            this.headerClient = t, this.header = e, this.headerLength = r, this.indexLength = n
        }

        static async open(t) {
            const e = new It(t), r = (() => {
                let t, e = 0;
                for (t = 0; t < 3; t++) {
                    e += 16 ** t * 40
                }
                return e
            })(), n = 2024 + r;
            pt.debug(`fetching header. minReqLength: ${n} (assumedHeaderLength: 2024, assumedIndexLength: ${r})`);
            {
                const t = new Uint8Array(await e.getRange(0, 8, n, "header"));
                if (!t.subarray(0, 3).every(((t, e) => mt[e] === t))) throw pt.error(`bytes: ${t} != ${mt}`), new Error("Not a FlatGeobuf file");
                pt.debug("magic bytes look good")
            }
            let s;
            {
                const t = await e.getRange(8, 4, n, "header");
                s = new DataView(t).getUint32(0, !0);
                if (s > 10485760 || s < 8) throw new Error("Invalid header size");
                pt.debug(`headerLength: ${s}`)
            }
            const i = await e.getRange(12, s, n, "header"), o = new I(new Uint8Array(i)), a = L.fromByteBuffer(o),
                h = yt(a.featuresCount, a.indexNodeSize);
            return pt.debug("completed: opening http reader"), new vt(e, a, s, h)
        }

        async* selectBbox(t) {
            const e = this.lengthBeforeTree(), r = this.headerClient, n = async function (t, n) {
                return r.getRange(e + t, n, 0, "index")
            }, s = [];
            let i = [];
            for await(const e of gt(this.header.featuresCount, this.header.indexNodeSize, t, n)) {
                const [t, ,] = e;
                let [, , r] = e;
                if (!r) {
                    pt.info("final feature");
                    r = _t.global.extraRequestThreshold()
                }
                if (0 == i.length) {
                    i.push([t, r]);
                    continue
                }
                const n = i[i.length - 1], o = t - (n[0] + n[1]);
                o > _t.global.extraRequestThreshold() && (pt.info(`Pushing new feature batch, since gap ${o} was too large`), s.push(i), i = []), i.push([t, r])
            }
            this.headerClient.logUsage("header+index"), i.length > 0 && s.push(i);
            const o = s.flatMap((t => this.readFeatureBatch(t)));
            yield* ut.merge(o)
        }

        lengthBeforeTree() {
            return mt.length + 4 + this.headerLength
        }

        lengthBeforeFeatures() {
            return this.lengthBeforeTree() + this.indexLength
        }

        buildFeatureClient() {
            return new It(this.headerClient.httpClient)
        }

        async* readFeatureBatch(t) {
            const [e] = t[0], [r, n] = t[t.length - 1], s = r + n - e, i = this.buildFeatureClient();
            for (const [e] of t) yield await this.readFeature(i, e, s);
            i.logUsage("feature")
        }

        async readFeature(t, e, r) {
            const n = e + this.lengthBeforeFeatures();
            let s;
            {
                const e = await t.getRange(n, 4, r, "feature length");
                s = new DataView(e).getUint32(0, !0)
            }
            const i = await t.getRange(n + 4, s, r, "feature data"), o = new Uint8Array(i), a = new Uint8Array(s + 4);
            a.set(o, 4);
            const h = new I(a);
            return h.setPosition(4), B.getRootAsFeature(h)
        }
    }

    class It {
        constructor(t) {
            this.bytesEverUsed = 0, this.bytesEverFetched = 0, this.buffer = new ArrayBuffer(0), this.head = 0, this.httpClient = "string" == typeof t ? new Ft(t) : t
        }

        async getRange(t, e, r, n) {
            this.bytesEverUsed += e;
            const s = t - this.head, i = s + e;
            if (s >= 0 && i <= this.buffer.byteLength) return this.buffer.slice(s, i);
            const o = Math.max(e, r);
            return this.bytesEverFetched += o, pt.debug(`requesting for new Range: ${t}-${t + e - 1}`), this.buffer = await this.httpClient.getRange(t, o, n), this.head = t, this.buffer.slice(0, e)
        }

        logUsage(t) {
            const e = t.split(" ")[0], r = this.bytesEverUsed, n = this.bytesEverFetched, s = (100 * r / n).toFixed(2);
            pt.info(`${e} bytes used/requested: ${r} / ${n} = ${s}%`)
        }
    }

    class Ft {
        constructor(t) {
            this.requestsEverMade = 0, this.bytesEverRequested = 0, this.url = t
        }

        async getRange(t, e, r) {
            this.requestsEverMade += 1, this.bytesEverRequested += e;
            const n = `bytes=${t}-${t + e - 1}`;
            pt.info(`request: #${this.requestsEverMade}, purpose: ${r}), bytes: (this_request: ${e}, ever: ${this.bytesEverRequested}), Range: ${n}`);
            return (await fetch(this.url, {headers: {Range: n}})).arrayBuffer()
        }
    }

    function Pt(t) {
        const e = function (t) {
            const e = t[0], r = e.getProperties ? e.getProperties() : {};
            let n = null;
            r && (n = Object.keys(r).filter((t => "geometry" !== t)).map((t => new C(t, function (t) {
                if ("boolean" == typeof t) return P.Bool;
                if ("number" == typeof t) return t % 1 == 0 ? P.Int : P.Double;
                if ("string" == typeof t) return P.String;
                if (null === t) return P.String;
                throw new Error(`Unknown type (value '${t}')`)
            }(r[t]), null, null, -1, -1, -1, !0, !1, !1))));
            const s = function (t) {
                let e;
                for (const n of t) {
                    if (e === x.Unknown) break;
                    const t = (r = n).getGeometry ? M(r.getGeometry().getType()) : M(r.geometry.type);
                    void 0 === e ? e = t : e !== t && (e = x.Unknown)
                }
                var r;
                if (void 0 === e) throw new Error("Could not infer geometry type for collection of features.");
                return e
            }(t);
            return new L(s, n, t.length, 0, null, null, null, null)
        }(t), r = function (t) {
            const e = new F;
            let r = null;
            t.columns && (r = A.createColumnsVector(e, t.columns.map((t => function (t, e) {
                const r = t.createString(e.name);
                return E.startColumn(t), E.addName(t, r), E.addType(t, e.type), E.endColumn(t)
            }(e, t)))));
            const n = e.createString("L1");
            A.startHeader(e), A.addFeaturesCount(e, new m(t.featuresCount, 0)), A.addGeometryType(e, t.geometryType), A.addIndexNodeSize(e, 0), r && A.addColumns(e, r);
            A.addName(e, n);
            const s = A.endHeader(e);
            return e.finishSizePrefixed(s), e.asUint8Array()
        }(e), n = t.map((t => {
            if (!t.getGeometry) throw new Error("Missing getGeometry implementation");
            if (!t.getProperties) throw new Error("Missing getProperties implementation");
            return z(j(t.getGeometry(), e.geometryType), t.getProperties(), e)
        })), s = n.map((t => t.length)).reduce(((t, e) => t + e)), i = new Uint8Array(mt.length + r.length + s);
        i.set(r, mt.length);
        let o = mt.length + r.length;
        for (const t of n) i.set(t, o), o += t.length;
        return i.set(mt), i
    }

    async function* xt(t, e, r) {
        const n = "function" == typeof (s = t).slice ? s : new O("function" == typeof s.read ? s : s.getReader());
        var s;
        const i = async t => await n.slice(t);
        let o = new Uint8Array(await i(8));
        if (!o.subarray(0, 3).every(((t, e) => mt[e] === t))) throw new Error("Not a FlatGeobuf file");
        o = new Uint8Array(await i(4));
        let a = new I(o);
        const h = a.readUint32(0);
        o = new Uint8Array(await i(h)), a = new I(o);
        const u = L.fromByteBuffer(a);
        r && r(u);
        const {indexNodeSize: c, featuresCount: l} = u;
        if (c > 0) {
            const t = yt(l, c);
            await i(t)
        }
        let b;
        for (; b = await Ut(i, u, e);) yield b
    }

    async function Ut(t, e, r) {
        let n = new Uint8Array(await t(4, "feature length"));
        if (0 === n.byteLength) return;
        let s = new I(n);
        const i = s.readUint32(0);
        n = new Uint8Array(await t(i, "feature data"));
        const o = new Uint8Array(i + 4);
        o.set(n, 4), s = new I(o), s.setPosition(4);
        return r(B.getRootAsFeature(s), e)
    }

    function St(t, e) {
        let r;
        if (r = e === x.Unknown ? null == t ? void 0 : t.type() : e, !t) return;
        if (t.xyArray()) {
            const e = Array.from(t.xyArray()), n = t.endsArray(), s = n ? Array.from(n.map((t => t << 1))) : [e.length];
            switch (r) {
                case x.Point:
                    return new c.default(e);
                case x.MultiPoint:
                    return new l.default(e, "XY");
                case x.LineString:
                    return new b.default(e, "XY");
                case x.MultiLineString:
                    return new f.default(e, "XY", s);
                case x.Polygon:
                    return new d.default(e, "XY", s)
            }
        } else if (r === x.MultiPolygon) {
            const e = new _.default([]);
            for (let r = 0; r < t.partsLength(); r++) e.appendPolygon(St(t.parts(r), x.Polygon));
            return e
        }
        throw new Error("Unknown type")
    }

    function Ot(t, e) {
        return $(t, e, (function (t, e) {
            return St(t, e)
        }), (function (t, e) {
            return function (t, e) {
                const r = new u.default(t);
                return e && r.setProperties && r.setProperties(e), r
            }(t, e)
        }))
    }

    function Ct(t, e) {
        return function (t, e, r) {
            if (!t.subarray(0, 3).every(((t, e) => mt[e] === t))) throw new Error("Not a FlatGeobuf file");
            const n = new I(t), s = n.readUint32(mt.length);
            n.setPosition(mt.length + 4);
            const i = L.fromByteBuffer(n);
            r && r(i);
            let o = mt.length + 4 + s;
            const {indexNodeSize: a, featuresCount: h} = i;
            a > 0 && (o += yt(h, a));
            const u = [];
            for (; o < n.capacity();) {
                const t = n.readUint32(o);
                n.setPosition(o + 4);
                const r = B.getRootAsFeature(n);
                u.push(e(r, i)), o += 4 + t
            }
            return u
        }(t, Ot, e)
    }

    function Et(t, e, r) {
        return async function* (t, e, r, n) {
            const s = await vt.open(t);
            pt.debug("opened reader"), n && n(s.header);
            for await(const t of s.selectBbox(e)) yield r(t, s.header)
        }(t, e, Ot, r)
    }

    t.deserialize = function (t, e, r) {
        return t instanceof Uint8Array ? Ct(t, r) : t instanceof ReadableStream ? function (t, e) {
            return xt(t, Ot, e)
        }(t, r) : Et(t, e, r)
    }, t.serialize = function (t) {
        return Pt(t)
    }, Object.defineProperty(t, "__esModule", {value: !0})
}));
//# sourceMappingURL=flatgeobuf-ol.min.js.map
